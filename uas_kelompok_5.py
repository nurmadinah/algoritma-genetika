# -*- coding: utf-8 -*-
"""UAS KELOMPOK 5

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VzWU1kFelN-qqgBrf00cZD-kYch5QW5T
"""

import random
import string
import time

start_time = time.time()

# Target string yang ingin dicapai
target = "PEMROGRAMAN LANJUTAN"

# Parameter algoritma genetika
population_size = 100
mutation_rate = 0.03
generations = 1000
parents_count = 3  # Jumlah orangtua yang digunakan dalam crossover
children_count = 2  # Jumlah anak yang dihasilkan dalam crossover

# Fungsi untuk menginisialisasi populasi
def initialize_population(size, length):
    return [''.join(random.choices(string.ascii_uppercase + " ", k=length)) for _ in range(size)]

# Fungsi untuk menghitung fitness individu
def calculate_fitness(individual):
    return sum(1 for i in range(len(individual)) if individual[i] == target[i])

# Fungsi untuk memilih individu berdasarkan fitness
def selection(population, num_parents):
    weights = [calculate_fitness(ind) for ind in population]
    total_fitness = sum(weights)
    probabilities = [w / total_fitness for w in weights]
    return random.choices(population, probabilities, k=num_parents)

# Fungsi untuk melakukan crossover antara tiga individu dan menghasilkan dua anak
def crossover(parents):
    length = len(parents[0])
    crossover_points = sorted(random.sample(range(1, length), 2))
    children = []
    for i in range(children_count):
        child = (parents[i % parents_count][:crossover_points[0]] +
                 parents[(i + 1) % parents_count][crossover_points[0]:crossover_points[1]] +
                 parents[(i + 2) % parents_count][crossover_points[1]:])
        children.append(child)
    return children

# Fungsi untuk melakukan mutasi pada individu
def mutate(individual, mutation_rate):
    return ''.join(random.choice(string.ascii_uppercase + " ") if random.random() < mutation_rate else char
                   for char in individual)

# Fungsi utama algoritma genetika
def genetic_algorithm():
    population = initialize_population(population_size, len(target))
    for generation in range(generations):
        population = sorted(population, key=calculate_fitness, reverse=True)
        if calculate_fitness(population[0]) == len(target):
            break
        next_population = population[:10]  # Elitisme: mempertahankan beberapa individu terbaik
        while len(next_population) < population_size:
            parents = selection(population, parents_count)
            children = crossover(parents)
            for child in children:
                child = mutate(child, mutation_rate)
                if len(next_population) < population_size:
                    next_population.append(child)
                else:
                    break
        population = next_population[:population_size]
        best_fitness = calculate_fitness(population[0])
        print(f"Generation {generation + 1}: Best fitness = {best_fitness}, Best individual = {population[0]}")
    return population[0]

# Menjalankan algoritma genetika
best_individual = genetic_algorithm()
print(f"\nBest individual: {best_individual}")

waktu = time.time() - start_time
print("\nWaktu komputasi:", waktu, "detik")
if waktu > 0:
    generations_per_second = (generations + 1) / waktu
else:
    generations_per_second = 0.0  # to avoid division by zero error
print("Kecepatan running: {:.2f} generasi/detik\n".format(generations_per_second))